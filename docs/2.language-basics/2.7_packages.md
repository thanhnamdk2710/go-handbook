# Understanding Go Packages and Modules

Packages are the building blocks of Go applications. This guide covers everything you need to know about working with packages and modules in Go.

## Package Basics

### Package Declaration

```go
// File: user.go
package users

// Package-level variables
var (
    defaultRole = "user"
    MaxUsers    = 1000 // Exported
)

// Exported type
type User struct {
    ID   string
    Name string
    role string // Unexported
}

// Exported function
func NewUser(name string) *User {
    return &User{
        Name: name,
        role: defaultRole,
    }
}
```

### Package Organization

```txt
myapp/
├── go.mod
├── go.sum
├── main.go
├── users/
│   ├── user.go
│   ├── validation.go
│   └── database.go
└── config/
    ├── config.go
    └── defaults.go
```

## Package Visibility

### Exported vs Unexported

```go
package math

// Exported (public) - starts with uppercase
func Calculate(x int) int {
    return multiply(x, 2)
}

// Unexported (private) - starts with lowercase
func multiply(x, y int) int {
    return x * y
}

// Exported type with both exported and unexported fields
type Rectangle struct {
    Width  float64 // Exported
    Height float64 // Exported
    area   float64 // Unexported
}
```

### Using Packages

```go
package main

import (
    "fmt"
    "myapp/users"
    "myapp/config"
)

func main() {
    user := users.NewUser("NamNguyen")
    fmt.Printf("Created user: %v\n", user)

    // Can't access unexported members
    // user.role = "admin" // Compilation error
}
```

## Package Documentation

### Package Comments

```go
// Package users provides user management functionality.
// It handles user creation, validation, and persistence.
package users

// User represents a system user with basic information.
type User struct {
    ID   string
    Name string
}

// NewUser creates a new user with the given name.
// It returns nil if the name is invalid.
func NewUser(name string) *User {
    if name == "" {
        return nil
    }
    return &User{Name: name}
}
```

### Example Tests

```go
package users_test

func Example() {
    user := users.NewUser("Alice")
    fmt.Printf("User: %v\n", user)
    // Output: User: {ID: Name:Alice}
}

func ExampleNewUser() {
    user := users.NewUser("Bob")
    fmt.Printf("Name: %s\n", user.Name)
    // Output: Name: Bob
}
```

## Package Initialization

### Init Function

```go
package database

import "log"

var db *Database

func init() {
    // Initialize package
    var err error
    db, err = Connect()
    if err != nil {
        log.Fatal(err)
    }
}

func GetDB() *Database {
    return db
}
```

### Multiple Init Functions

```go
package config

// First init function
func init() {
    loadDefaults()
}

// Second init function
func init() {
    loadEnvironment()
}

// Third init function
func init() {
    validateConfig()
}
```

## Package Dependencies

### Import Statements

```go
package main

import (
    // Standard library
    "fmt"
    "log"

    // Third-party packages
    "github.com/gin-gonic/gin"

    // Local packages
    "myapp/users"
    "myapp/config"
)
```

### Import Aliases

```go
import (
    // Alias import
    mmath "math"

    // Dot import (avoid in production code)
    . "fmt"

    // Blank import
    _ "github.com/lib/pq"
)
```

## Package Management

### Go Modules

```bash
# Initialize a new module
go mod init myapp

# Add dependencies
go get  github.com/gin-gonic/gin

# Update dependencies
go get -u

# Tidy dependencies
go mod tidy
```

### Version Selection

```go
// go.mod
module myapp

go 1.21

require (
    github.com/gin-gonic/gin v1.9.1
    github.com/lib/pq v1.10.9
)
```

## Best Practices

### 1. Package Organization

```txt
myapp/
├── cmd/                    # Command-line applications
│   └── server/
│       └── main.go
├── internal/              # Private application code
│   ├── auth/
│   └── database/
├── pkg/                   # Public library code
│   ├── models/
│   └── utils/
└── api/                   # API definitions
    └── proto/
```

### 2. Package Naming

```go
// Good package names
package users
package database
package config

// Avoid
package utils   // Too generic
package common  // Too generic
package helper  // Too generic
```

### 3. Interface Definition

```go
// Good: Define interfaces where they are used
package client

type Service interface {
    Get(id string) (*Response, error)
    List() ([]*Response, error)
}

// Implementation can be in a different package
package server

type service struct {}

func (s *service) Get(id string) (*client.Response, error) {
    // Implementation
}
```

## Common Patterns

### 1. Options Pattern

```go
package server

type Option func(*Server)

func WithPort(port int) Option {
    return func(s *Server) {
        s.port = port
    }
}

func New(options ...Option) *Server {
    s := &Server{
        port: 8080 // Default
    }

    for _, opt := range options {
        opt(s)
    }

    return s
}
```

### 2. Builder Pattern

```go
package query

type Builder struct {
    table string
    where string
    limit int
}

func NewBuilder() *Builder {
    return &Builder{}
}

func (b *Builder) Table(name string) *Builder {
    b.table = name
    return b
}

func (b *Builder) Build() string {
    // Build query
    return fmt.Sprintf("SELECT * FROM %s", b.table)
}
```

### 3. Factory Pattern

```go
package storage

type Store interface  {
    Save(data []byte) error
    Load() ([]byte, error)
}

func NewStore(kind string) Store {
    switch kind {
    case "file":
        return &FileStore{}
    case "memory":
        return &MemoryStore{}
    default:
        return &NullStore{}
    }
}
```

## Testing Packages

### Table Tests

```go
package users

import "testing"

func TestValidateUser(t *testing.T) {
    tests := []struct{
        name string
        user User
        wantErr bool
    }{
        {
            name: "valid user",
            user: User{Name: "Alice"},
            wantErr: false,
        },
        {
            name: "invalid user",
            user: User{Name: ""},
            wantErr: true,
        },
    }

    for _, tt := tests {
        t.Run(tt.name, func(t *testing.T) {
            err := tt.user.Validate()
            if (err != nil) != tt.wantErr {
                t.Errorf("Validate() error = %v, wantErr %v", err, tt.wantErr)
            }
        })
    }
}
```

### Mocks and Interfaces

```go
package users

type Repository interface {
    Save(user *User) error
    Find(id string) (*User, error)
}

// Mock implementation for testing
type MockRepository struct {
    users map[string]*User
}

func NewMockRepository() *MockRepository {
    return &MockRepository{
        users: make(map[string]*User),
    }
}

func (m *MockRepository) Save(user *User) error {
    m.users[user.ID] = user
    return nil
}
```

## Next Steps

Start learning [Error Handling](2.8_error_handling.md) in Go

## Additional Resources

- [Go Documentation](https://go.dev/doc)
- [Go by Example](https://gobyexample.com)
- [Go Tour](https://go.dev/tour/welcome/1)
- [Effective Go](https://go.dev/doc/effective_go)
- [Go Playground](https://go.dev/play)
- [WebReference - Guide to Go](https://webreference.com/go)
