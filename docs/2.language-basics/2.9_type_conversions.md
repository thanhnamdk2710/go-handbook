# Understanding Type Conversions in Go Programming

Type conversion in Go is the process of converting values from one type to another. This guide covers all aspects of type conversion and best practices for safe type handling.

## Basic Type Conversions

### Numeric Conversions

```go
// Integer conversions
i := 42
var f float64 = float64(i) // int to float64
var u uint = uint(i)       // int to uint

// Float conversions
f = 3.14
i = int(f) // float64 to int (truncates)

// Complex number conversions
c := complex(3.0, 4.0) // float64 to complex128
r := real(c)           // get real part
im := imag(c)          // get imaginary part
```

### String Conversions

```go
// Integer to string
i := 42
s := strconv.Itoa(i)     // int to string
s = fmt.Sprintf("%d", i) // alternative method

// String to integer
i, err := strconv.Atoi("42") // string to int
if err != nil {
    // handle error
}

// String to other numeric types
f, err := strconv.ParseFloat("3.14", 64)
i64, err := strconv.ParseInt("42", 10, 64)
u64, err := strconv.ParseUint("42", 10, 64)
```

## Type Assertions

### Basic Type Assertions

```go
var i interface{} = "hello"

// Type assertion
s, ok := i.(string)
if ok {
    fmt.Println(s) // "hello"
} else {
    fmt.Println("not a string")
}

// Direct assertion (panic if wrong type)
s = i.(string)
```

### Type Switches

```go
func handleValue(i interface{}) {
    switch v := i.(type) {
    case int:
        fmt.Printf("Integer: %d\n", v)
    case string:
        fmt.Printf("String: %s\n", v)
    case bool:
        fmt.Printf("Boolean: %v\n", v)
    default:
        fmt.Printf("Unknown type: %T\n", v)
    }
}
```

## Interface Conversions

```go
type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}

// Converting between interfaces
var r Reader = os.Stdin
w, ok := r.(Writer)
if ok {
    // r also implements Writer
}
```

## Best practices

### 1. Safe Conversions

```go
// Good: Safe integer conversion
func safeIntToUint(i int) (uint, error) {
    if i < 0 {
        return 0, fmt.Errorf("negative value: %d", i)
    }
    return uint(i), nil
}

// Good: Safe string to number conversion
func safeStringToInt(s string) (int, error) {
    return strconv.Atoi(s)
}
```

### 2. Type Assertion Safety

```go
// Good: Safe type assertion
func processValue(v interface{}) {
    if str, ok := v.(string) {
        // Process string
        fmt.Println("String:", str)
        return
    }
    // Handle other type
}

// Avoid: Unsafe type assertion
func unsafeProcess(v interface{}) string {
    return v.(string) // Panic if v is not string
}
```

### 3. Error Handling

```go
// Good: Handle conversion errors
func convertString(s string) (int, error) {
    i, err := strconv.Atoi(s)
    if err != nil {
        return 0, fmt.Errorf("failed to convert %q: %w", s, err)
    }
    return i, nil
}
```

## Common Patterns

### 1. Custom Type Conversions

```go
type Celsius float64
type Fahrenheit float64

// Conversion methods
func (c Celsius) ToFahrenheit() Fahrenheit {
    return Fahrenheit(c * 9 / 5 + 32)
}

func (f Fahrenheit) ToCelsius() Celsius {
    return Celsius((f - 32) * 5 / 9)
}
```

### 2. Generic Type Conversions

```go
// Generic conversion function
func convert[T, U any](value T) (U, error) {
    var result U

    // Convert using reflection or type assertion
    // Implementation depends on specific types

    return result, nil
}
```

### 3. Batch Conversions

```go
// Convert slice of strings to integers
func stringsToInts(strings []string) ([]int, error) {
    ints := make([]int, len(strings))
    for i, s := range strings {
        n, err := strconv.Atoi(s)
        if err != nil {
            return nil, fmt.Errorf("invalid integer at index %d: %w", i, err)
        }
        ints[i] = n
    }
    return ints, nil
}
```

## Performance Considerations

### 1. Avoid Unnecessary Conversions

```go
// Bad: Unnecessary conversions
func badExample() {
    i := 42
    f := float64(i)
    i = int(f) // Unnecessary round trip
}

// Good: Keep original type when possible
func goodExample() {
    i := 42
    // Use i directly if float64 not needed
}
```

### 2. String Conversions

```go
// Expensive: Multiple string conversions
s := strconv.Itoa(i) + strconv.Itoa(j)

// Better: Use fmt.Sprintf
s := fmt.Sprintf("%d%d", i, j)

// Best: Use strings.Builder
var b strings.Builder
b.WriteString(strconv.Itoa(i))
b.WriteString(strconv.Itoa(j))
s := b.String()
```

## Common Mistakes

### 1. Loss of Precision

```go
// Wrong: Possible loss of precision
f := 3.99
i := int(f) // i = 3 (truncated)

// Right: Round if needed
i = int(math.Round(f)) // i = 4
```

### 2. Range Overflow

```go
// Wrong: Possible overflow
i := 1000000
b := byte(i) // Possible overflow

// Right: Check range
if i >= 0 && i <= 255 {
    b :=byte(i)
} else {
    // Handle error
}
```

### 3. Nil Interface Conversions

```go
// Wrong: Converting nil interface
var i interface{}
s := i.(string) // Panics

// Right: Check for nil
if i != nil {
    if s, ok := i.(string); ok {
        // Use s
    }
}
```

## Next Steps

Start learning Defer and Panic in Go Programming

## Additional Resources

- [Go Documentation](https://go.dev/doc)
- [Go by Example](https://gobyexample.com)
- [Go Tour](https://go.dev/tour/welcome/1)
- [Effective Go](https://go.dev/doc/effective_go)
- [Go Playground](https://go.dev/play)
- [WebReference - Guide to Go](https://webreference.com/go)
