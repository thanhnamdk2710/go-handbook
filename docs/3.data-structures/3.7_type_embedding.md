# Understanding Type Embedding in Go Programming

Type embedding is a powerful feature in Go that enables composition and code reuse through embedding one type within another. This guide covers everything you need to know about type embedding.

## Struct Embedding

### Basic Struct Embedding

```go
type Animal struct {
    Name string
    Age  int
}

type Dog struct {
    Animal // Embedded struct
    Breed string
}

// Usage
dog := Dog{
    Animal: Animal{
        Name: "Rex",
        Age:  3,
    },
    Breed: "German Shepherd",
}

// Access embedded fields directly
fmt.Println(dog.Name) // "Rex"
fmt.Println(dog.Age)  // 3
```

### Multiple Embedding

```go
type Walker struct {
    Speed int
}

type Barker struct {
    Volume int
}

type Dog struct {
    Animal
    Walker
    Barker
    Breed string
}

// Usage
dog := Dog{
    Animal: Animal{Name: "Rex", Age: 3},
    Walker: Walker{Speed: 5},
    Barker: Barker{Volume: 8},
    Breed: "German Shepherd",
}
```

## Interface Embedding

### Basic Interface Embedding

```go
type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}

type ReadWriter interface {
    Reader
    Writer
}
```

### Multiple Interface Embedding

```go
type Closer interface {
    Close() error
}

type ReadWriteCloser interface {
    Reader
    Writer
    Closer
}
```

## Methods and Embedding

### Embedded Methods

```go
type Animal struct {
    Name string
}

func (a Animal) Speak() string {
    return fmt.Sprintf("%s makes a sound", a.Name)
}

type Dog struct {
    Animal
}

// Dog inherits Speak method
dog := Dog{Animal{Name: "Rex"}}
fmt.Println(dog.Speak()) // "Rex makes a sound"
```

### Method Overriding

```go
type Dog struct {
    Animal
}

// Override Speak method
func (d Dog) Speak() string {
    return fmt.Sprintf("%s barks", d.Name)
}

dog := Dog{Animal{Name: "Rex"}}
fmt.Println(dog.Speak()) // "Rex barks"
```

## Best Practices

### 1. Composition over Inheritance

```go
// Good: Composition
type Logger struct {
    Level int
}

type HTTPServer struct {
    Logger // Embed for logging capacity
    Address string
}

// Avoid: Trying to simulate inheritance
type BaseServer struct {
    Address string
}

type HTTPServer struct {
    BaseServer // Don't use embedding just to inherit
}
```

### 2. Interface Segregation

```go
// Good: Small, focused interfaces
type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}

// Compose as needed
type ReadWriter interface {
    Reader
    Writer
}

// Avoid: Large interfaces
type DoEverything interface {
    Read(p []byte) (n int, err error)
    Write(p []byte) (n int, err error)
    Close() error
    Flush() error
    // Too many methods...
}
```

### 3. Naming Conventions

```go
// Good: Clear embedding
type Config struct {
    Logger   // Clearly shows logging capacity
    Database // Clearly shows database capacity
}

// Avoid: Ambiguous names
type Server struct {
    Base    // What does Base provide?
    Handler // What kind of handlers?
}
```

## Common Patterns

### 1. Middleware Pattern

```go
type Middleware struct {
    Next http.Handler
}

type LoggingMiddleware struct {
    Middleware
    Logger *log.Logger
}

func (m LoggingMiddleware) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    m.Logger.Printf("Request: %s %s", r.Method, r.URL.Path)
    m.Next.ServeHTTP(w, r)
}
```

### 2. Options Pattern

```go
type Config struct {
    Address string
    Port    int
}

type Server struct {
    Config  // Embed configuration
    handler http.Handler
}

func NewServer(opts ...func(*Server)) *Server {
    s := &Server{
        Config: Config{
            Address: "localhost",
            Port:    8080,
        },
    }

    for _, opt := range opts {
        opt(s)
    }

    return s
}
```

### 3. Decorator Pattern

```go
type Component interface {
    Operation() string
}

type ConcreteComponent struct{}

func (c ConcreteComponent) Operation() string {
    return "ConcreteComponent"
}

type Decorator struct {
    Component
}

type ConcreteDecorator struct {
    Decorator
}

func (d ConcreteDecorator) Operation() string {
    return "Decorated(" + d.Component.Operation() + ")"
}
```

## Performance Considerations

### 1. Memory Layout

```go
// Good: Efficient memory layout
type Efficient struct {
    a int64   // 8 bytes
    b float64 // 8 bytes
    c int32   // 4 bytes
    d int32   // 4 bytes
}

// Bad: Inefficient due to padding
type Inefficient struct {
    a int32 // 4 bytes + 4 padding
    b int64 // 8 bytes
    c int32 // 4 bytes + 4 padding
}
```

### 2. Method Calls

```go
// Direct method call (faster)
func (d Dog) Bark() {
    fmt.Println("Woof!")
}

// Embedded method call (slight overhead)
func (a Animal) MakeSound() {
    fmt.Println("Sound!")
}

type Dog struct {
    Animal
}
```

## Common Mistakes

### 1. Name Conflicts

```go
type A struct {
    Name string
}

type B struct {
    Name string
}

// Wrong: Ambiguous field access
type C struct {
    A
    B
}

// Right: Use explicit naming
type C struct {
    A
    B
    Name string // Override embedded fields
}
```

### 2. Circular Embedding

```go
// Wrong: Circular embedding
type A struct {
    *B
}

type B struct {
    *A
}

// Right: Use composition differently
type A struct {
    B *B
}

type B struct {
    A *A
}
```

### 3. Interface Pollution

```go
// Wrong: Too many embedded interfaces
type SuperInterface interface {
    io.Reader
    io.Writer
    io.Closer
    fmt.Stringer
    json.Marshaler
    // Too many requirements
}

// Right: Keep interfaces focused
type FileProcessor interface {
    io.Reader
    io.Writer
    Process() error
}
```

## Next Steps

Start learning [Custom Type](3.8_custom_types.md)

## Additional Resources

- [Go Documentation](https://go.dev/doc)
- [Go by Example](https://gobyexample.com)
- [Go Tour](https://go.dev/tour/welcome/1)
- [Effective Go](https://go.dev/doc/effective_go)
- [Go Playground](https://go.dev/play)
- [WebReference - Guide to Go](https://webreference.com/go)
