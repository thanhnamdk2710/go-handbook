# Understanding Concurrency in Go Programming

Go's approach to concurrency is one of its most distinctive and powerful features. This guide covers everything you need to know about concurrent programming in Go.

## Core Concepts

1. [Goroutines](4.1_goroutines.md)

   - Lightweight threads
   - Concurrent execution
   - Scheduling
   - Best Practices

2. [Channels](4.2_channels.md)

   - Communication
   - Synchronization
   - Buffered channels
   - Channel patterns

3. [Select](4.3_select.md)

   - Multiple channel operations
   - Timeouts
   - Default cases
   - Common patterns

4. [Mutexes](4.4_mutexes.md)

   - Synchronization
   - Lock types
   - Best practices
   - Deadlock prevention

5. Context

   - Cancellation
   - Timeouts
   - Value propagation
   - Best practices

## Advanced Topics

- Race Conditions
- Worker Pools
- Rate Limiting

## Common Patterns

### 1. Basic Goroutine

```go
// Launch concurrent operation
go func() {
  // Do work
  fmt.Println("Working...")
}()
```

### 2. Channel Communication

```go
// Create channel
ch := make(chan string)

// Send data
go func() {
  ch <- "Hello"
}()

// Receive data
msg := <-ch
```

### 3. Worker Pool

```go
func worker(id int, jobs <-chan int, results chan<- int) {
  for j := range jobs {
    results <- j * 2
  }
}

func main() {
  jobs := make(chan int, 100)
  results := make(chan int, 100)

  // Start workers
  for w := 1; w <= 3; w++ {
    go worker(w, jobs, results)
  }

  // Send jobs
  for j := 1; j <= 9; j++ {
    jobs <- j
  }
  close(jobs)

  // Collect results
  for a := 1; a <= 9; a++ {
    <-results
  }
}
```

## Best Practices

### 1. Goroutine Management

- Always know how your goroutines will end
- Use WaitGroups for synchronization
- Handle panic in goroutines
- Consider using worker pools

```go
var wg sync.WaitGroup
wg.Add(1)
go func() {
  defer wg.Done()
  // Do work
}()
wg.Wait()
```

### 2. Channel Usage

- Use buffered channels when appropriate
- Always close channels from the sender side
- Handle closed channels gracefully
- Use directional channel parameters

```go
// Sender
func produce(ch chan<- int) {
  defer close(ch)
  for i := 0; i < 5; i++ {
    ch <- i
  }
}

// Receiver
func consume(ch <-chan int) {
  for v := range ch {
    fmt.Println(v)
  }
}
```

### 3. Error Handling

```go
func doWork() error {
  errCh := make(chan error, 1)
  go func() {
    if err := riskyOperation(); err != nil {
      errCh <- err
      return
    }
    errCh <- nil
  }()

  select{
  case err := <-errCh:
    return err
  case <-time.After(time.Second):
    return errors.New("timeout")
  }
}
```

## Common Concurrency Patterns

### 1. Pipeline Pattern

```go
func gen(nums ...int) <-chan int {
  out := make(chan int)
  go func() {
    defer close(out)
    for _, n := range nums {
      out <- n
    }
  }()
  return out
}

func sq(in <-chan int) <-chan int {
  out := make(chan int)
  go func() {
    defer close(out)
    for n := range in {
      out <- n * n
    }
  }()
  return out
}
```

### 2. Fan-out, Fan-in

```go
func fanOut(ch <-chan int, n int) []<-chan int {
  outputs := make([]<-chan int, n)
  for i := 0; i < n; i++ {
    outputs[i] = sq(ch)
  }
  return outputs
}

func fanIn(channels ...<-chan int) <-chan int {
  var wg sync.WaitGroup
  merged := make(chan int)

  forward := func(c <-chan int) {
    defer wg.Done()
    for n := range c {
      merged <- n
    }
  }

  wg.Add(len(channels))
  for _, c := range channels {
    go forward(c)
  }

  go func() {
    wg.Wait()
    close(merged)
  }()

  return merged
}
```

## Performance Considerations

1. Goroutine Overhead

   - Goroutines are lightweight but not free
   - Consider pooling for very high numbers
   - Monitor goroutine count

2. Channel Operations

   - Buffered vs unbuffered trade-off
   - Channel closure costs
   - Select performance

3. Synchronization Costs
   - Mutex vs channel trade-offs
   - Lock contention
   - Memory synchronization

## Debugging Concurrent Programs

1. Race Detector

```bash
go run -race main.go
go test -race ./...
```

2. Deadlock Detection

   - Go runtime automatically detects deadlocks
   - Use timeout patterns for prevention

3. Profiling

```go
import _ "net/http/pprof"
```

## Next Steps

Start learning [Goroutines](4.1_goroutines.md)

## Additional Resources

- [Go Documentation](https://go.dev/doc)
- [Go by Example](https://gobyexample.com)
- [Go Tour](https://go.dev/tour/welcome/1)
- [Effective Go](https://go.dev/doc/effective_go)
- [Go Playground](https://go.dev/play)
- [WebReference - Guide to Go](https://webreference.com/go)
