# Understanding Select Statements in Go Programming

The select statement is a fundamental control structure in Go that enables you to work with multiple channel operations. This guide covers everything you need to know about using select effectively.

## Select Basics

### Basic Select Usage

```go
// Basic select with two channels
select {
case msg1 := <-ch1:
    fmt.Println("Received from ch1:", msg1)
case msg2 := <-ch2:
    fmt.Println("Received from ch2:", msg2)
}

// Select with send operations
select {
case ch1 <- value1:
    fmt.Println("Sent to ch1")
case ch2 <- value2:
    fmt.Println("Sent to ch2")
}
```

### Default Case

```go
// Non-blocking select
select {
case msg := <-ch:
    fmt.Println("Received:", msg)
default:
    fmt.Println("No message available")
}

// Non-blocking send
select {
case ch <- value:
    fmt.Println("Sent value")
default:
    fmt.Println("Cannot send value")
}
```

## Common Patterns

### 1. Timeout Pattern

```go
// Timeout for receive
select {
case msg := <-ch:
    fmt.Println("Received:", msg)
case <-time.After(time.Second):
    fmt.Println("Timeout waiting for message")
}

// Timeout for send
select {
case ch <- value:
    fmt.Println("Sent value")
case <-time.After(time.Second):
    fmt.Println("Timeout trying to send")
}
```

### 2. Done Channel Pattern

```go
func worker(done <-chan struct{}) {
    for {
        select {
        case <-done:
            fmt.Println("Worker shutting down")
            return
        default:
            // Do work
            time.Sleep(100 * time.Millisecond)
        }
    }
}

// Usage
done := make(chan struct{})
go worker(done)
time.Sleep(time.Second)
close(done) // Signal worker to stop
```

### 3. Multiple Channel Operations

```go
func process(input, output chan int, done chan struct{}) {
    for {
        select {
        case <-done:
            return
        case val := <-input:
            select {
            case output <- val * 2:
                // Value processed and sent
            case <-done:
                return
            }
        }
    }
}
```

## Best Practices

### 1. Channel Direction

```go
// Good: Clear channel direction
func worker(in <-chan int, out chan<- int, done <-chan struct{}) {
    for {
        select {
        case val := <-in:
            select {
            case out <- val * 2:
                // Processed
            case <-done:
                return
            }
        }
    }
}

// Usage
in := make(chan int)
out := make(chan int)
done := make(chan struct{})
go worker(in, out, done)
```

### 2. Error Handling

```go
type Result struct {
    Value int
    Err   error
}

func process(input <-chan int) <-chan Result {
    results := make(chan Result)
    go func() {
        defer close(results)
        for val := range input {
            select {
            case results <- Result{Value: val * 2}:
                // Sent successfully
            default:
                // Handle backpressure
                results <- Result{
                    Err: errors.New("channel full"),
                }
            }
        }
    }()
    return results
}
```

### 3. Context Usage

```go
func worker(ctx context.Context, input <-chan int) {
    for {
        select {
        case <-ctx.Done():
            fmt.Println("Context cancelled:", ctx.Err())
            return
        case val := <-input:
            // Process value
            fmt.Println("Processing:", val)
        }
    }
}

// Usage
ctx, cancel := context.WithTimeout(context.Background(), time.Second)
defer cancel()
go worker(ctx, inputChan)
```

## Common Patterns

### 1. Fan-in Pattern

```go
func fanIn(channels ...<-chan int) <-chan int {
    merged := make(chan int)
    var wg sync.WaitGroup

    // Start a goroutine for each input channel
    for _, ch := range channels {
        wg.Add(1)
        go func(c <-chan int) {
            defer wg.Done()
            for val := range c {
                select {
                case merged <- val:
                    // Value sent successfully
                }
            }
        }(ch)
    }

    // Close merged channel when all inputs are done
    go func() {
        wg.Wait()
        close(merged)
    }()

    return merged
}
```

### 2. Rate Limiting

```go
func rateLimiter(input <-chan int, rate time.Duration) <-chan int {
    output := make(chan int)
    ticker := time.NewTicker(rate)

    go func() {
        defer close(output)
        defer ticker.Stop()
        for val := range input {
            select {
            case <-ticker.C:
                output <- val
            }
        }
    }()

    return output
}

// Usage
input := make(chan int)
rateLimit := rateLimiter(input, 100*time.Millisecond)
```

### 3. Heartbeat Pattern

```go
func worker(done <-chan struct{}) <-chan struct{} {
    heartbeat := make(chan struct{})
    go func() {
        defer close(heartbeat)
        ticker := time.NewTicker(100 * time.Millisecond)
        defer ticker.Stop()

        for {
            select {
            case <-done:
                return
            case <-ticker.C:
                select {
                case heartbeat <- struct{}{}:
                    // Heartbeat sent
                default:
                    // Skip heartbeat if no one is listening
                }
            }
        }
    }()
    return heartbeat
}
```

## Performance Considerations

### 1. Case Order

```go
// Cases are evaluated in random order
select {
case <-ch1:
    // May not be evaluated first
case <-ch2:
    // May not be evaluated second
}

// Use priority with nested select
select {
case <-ch1:
    // High priority channel
default:
    select {
    case <-ch2:
        // Lower priority channel
      default:
        // No message available
    }
}
```

### 2. Channel Buffering

```go
// Unbuffered channels may block
select {
case unbufferedCh <- value:
    // Might block if no receiver
}

// Buffered channels provide some capacity
bufferedCh := make(chan int, 100)
select {
case bufferedCh <- value:
    // Won't block if buffer not full
}
```

## Common Mistakes

### 1. Blocking Forever

```go
// Wrong: May block forever
select {
case <-ch1:
    // Handle ch1
case <-ch2:
    // Handle ch2
}

// Right: Add timeout or default
select {
case <-ch1:
    // Handle ch1
case <-ch2:
    // Handle ch2
case <-time.After(time.Second):
    // Handle timeout
}
```

### 2. Resource Leaks

```go
// Wrong: Leaking goroutines
for {
    select {
    case ch <- value:
        return // Leaves goroutine running
    }
}

// Right: Clean shutdown
for {
    select {
    case ch <- value:
        return
    case <-done:
        return // Clean shutdown
    }
}
```

### 3. Missing Cases

```go
// Wrong: Missing error handling
select {
case data := <-dataCh:
    process(data)
}

// Right: Handle all cases
select {
case data := <-dataCh:
    if err := process(data); err != nil {
        handleError(err)
    }
case err := <-errCh:
    handleError(err)
case <-done:
    return
}
```

## Next Steps

Start learning [Mutexes](4.4_mutexes.md)

## Additional Resources

- [Go Documentation](https://go.dev/doc)
- [Go by Example](https://gobyexample.com)
- [Go Tour](https://go.dev/tour/welcome/1)
- [Effective Go](https://go.dev/doc/effective_go)
- [Go Playground](https://go.dev/play)
- [WebReference - Guide to Go](https://webreference.com/go)
