# Understanding and Preventing Race Conditions in Go Programming

Race conditions occur when multiple goroutines access shared resources without proper synchronization. This guide covers everything you need to know about detecting and preventing race conditions in Go.

## Understanding Race Conditions

### What is a Race Condition?

```go
package main

import (
  "fmt"
  "sync"
)

func main() {
  // Example of a race condition
  counter := 0
  var wg sync.WaitGroup

  for i := 0; i < 1000; i++ {
    wg.Add(1)
    go func(){
      defer wg.Done()
      counter++ // Race condition: unsynchronized access
    }()
  }

  wg.Wait()
  fmt.Println("Counter:", counter) // Result is unpredictable
}
```

### Types of Race Conditions

1. Data Race
   - Multiple goroutines accessing same memory location
   - At least one goroutine is writing
   - No synchronization between accesses
  
2. Check-Then-Act Race

```go
if value != nil {
  value.Method() // Race: value could be nil here
}
```

3. Read-Modify-Write Race

```go
x = x + 1 // Race: read and write not atomic
```

## Detecting Race Conditions

### Using the Race Detector

```bash
# Run with race detection
go run -race main.go

# Test with race detection
go test -race ./...

# Build with race detection
go build -race
```

### Example Race Detection Output

```go
package main

import (
  "fmt"
  "sync"
)

func main() {
  data := make(map[string]string)
  var wg sync.WaitGroup

  wg.Add(2)
  go func() {
    defer wg.Done()
    data["key"] = "value1" // Race: unsynchronized map access
  }()

  go func() {
    defer wg.Done()
    fmt.Println(data["key"]) // Race: concurrent read
  }

  wg.Wait()
}
```

## Preventing Race Conditions

### 1. Using Mutexes

```go
type SafeCounter struct {
  mu    sync.Mutex
  value int
}

func (c *SafeCounter) Increment() {
  c.mu.Lock()
  defer c.mu.Unlock()
  c.value++
}

func (c *SafeCounter) Value() int {
  c.mu.Lock()
  defer c.mu.Unlock()
  return c.value
}
```

### 2. Using Channels

```go
type Counter struct {
  ch chan int
  value int
}

func NewCounter() *Counter {
  c := &Counter{
    ch: make(chan int),
  }
  go func() {
    for {
      c.value += <-c.ch
    }
  }()
  return c
}

func (c *Counter) Increment() {
  c.ch <- 1
}
```

### 3. Using sync/atomic

```go
import "sync/atomic"

type AtomicCounter struct {
  value atomic.Int64
}

func (c *AtomicCounter) Increment() {
  c.value.Add(1)
}

func (c *AtomicCounter) Value() int64 {
  return c.value.Load()
}
```

## Next Steps

Start learning Race Conditions

## Additional Resources

- [Go Documentation](https://go.dev/doc)
- [Go by Example](https://gobyexample.com)
- [Go Tour](https://go.dev/tour/welcome/1)
- [Effective Go](https://go.dev/doc/effective_go)
- [Go Playground](https://go.dev/play)
- [WebReference - Guide to Go](https://webreference.com/go)
