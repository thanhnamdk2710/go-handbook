# Testing HTTP Servers and Clients in Go programming

Go's `net/http/httptest` package provides powerful tools for testing HTTP servers and clients. This guide covers how to write comprehensive HTTP tests.

## Testing HTTP Servers

### Basic Server Testing

```go
func TestHandler(t *testing.T) {
    // Create request
    req, err := http.NewRequest("GET", "/api/users", nil)
    if err != nil {
        t.Fatal(err)
    }

    // Create response recorder
    rr := httptest.NewRecorder()

    // Create handler
    handler := http.HandlerFunc(UserHandler)

    // Serve request
    handler.ServeHTTP(rr, req)

    // Check status code
    if status := rr.Code; status != http.StatusOK {
        t.Errorf("handler returned wrong status code: got %v want %v", status, http.StatusOK)
    }

    // Check response body
    expected := `{"status":"success"}`
    if rr.Body.String() != expected {
        t.Errorf("handler returned unexpected body: got %v want %v", rr.Body.String(), expected)
    }
}
```

### Testing with Query Parameters

```go
func TestHandlerWithParams(t *testing.T) {
    // Create request with query parameters
    req, err := http.NewRequest("GET", "/api/search", nil)
    if err != nil {
        t.Fatal(err)
    }

    q := req.URL.Query()
    q.Add("query", "test")
    q.Add("limit", "10")
    req.URL.RawQuery = q.Encode()

    rr := httptest.NewRecorder()
    handler := http.HandlerFunc(SearchHandler)
    handler.ServeHTTP(rr, req)

    if status := rr.Code; status != http.StatusOK {
        t.Errorf("handler returned wrong status code: got %v want %v", status, http.StatusOK)
    }
}
```

## Testing HTTP Clients

### Mock Server

```go
func TestClient(t *testing.T) {
    // Create test server
    server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Verify request
        if r.Method != "POST" {
            t.Errorf("expected POST request, got %s", r.Method)
        }

        // Send response
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)
        fmt.Fprintln(w, `{"id": "123", "status": "created"}`)
    }))
    defer server.Close()

    // Use test server URL
    client := NewClient(server.URL)
    resp, err := client.CreateUser(&User{Name: "John"})
    if err != nil {
        t.Fatal(err)
    }

    if resp.ID != "123" {
        t.Errorf("expected ID 123, got %s", resp.ID)
    }
}
```

### Testing Request Bodies

```go
func TestClientWithBody(t *testing.T) {
    var receivedBody []byte

    server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        var err error
        receivedBody, err = io.ReadAll(r.Body)
        if err != nil {
            t.Fatal(err)
        }

        w.WriteHeader(http.StatusOK)
    }))
    defer server.Close()

    client := NewClient(server.URL)
    data := map[string]string{"key": "value"}

    _, err := client.SendData(data)
    if err != nil {
        t.Fatal(err)
    }

    expected := `{"key":"value"}`
    if string(receivedBody) != expected {
        t.Errorf("expected body %s, got %s", expected, string(receivedBody))
    }
}
```

## Advanced Testing

### Testing Middleware

```go
func TestAuthMiddleware(t *testing.T) {
    tests := []struct {
        name       string
        token      string
        wantStatus int
    }{
        {
            name:       "valid token",
            token:      "valid-token",
            wantStatus: http.StatusOK,
        },
        {
            name:       "invalid token",
            token:      "invalid-token",
            wantStatus: http.StatusUnauthorized,
        },
            {
            name:       "missing token",
            token:      "",
            wantStatus: http.StatusUnauthorized,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            req := httptest.NewRequest("GET", "/api/protected", nil)
            if tt.token != "" {
                req.Header.Set("Authorization", "Bearer "+tt.token)
            }

            rr := httptest.NewRecorder()

            // Create handler chain
            handler := AuthMiddleware(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
                w.WriteHeader(http.StatusOK)
            }))

            handler.ServeHTTP(rr, req)

            if rr.Code != tt.wantStatus {
                t.Errorf("handler returned wrong status code: got %v want %v", rr.Code, tt.wantStatus)
            }
        })
    }
}
```

### Testing File Uploads

```go
func TestFileUpload(t *testing.T) {
    // Create multipart form
    body := &bytes.Buffer{}
    writer := multipart.NewWriter(body)

    // Add file to form
    part, err := writer.CreateFormFile("file", "test.txt")
    if err != nil {
        t.Fatal(err)
    }

    content := []byte("test content")
    if _, err := part.Write(content); err != nil {
        t.Fatal(err)
    }

    // Close writer
    writer.Close()

    // Create request
    req := httptest.NewRequest("POST", "/upload", body)
    req.Header.Set("Content-Type", writer.FormDataContentType())

    rr := httptest.NewRecorder()
    handler := http.HandlerFunc(UploadHandler)
    handler.ServeHTTP(rr, req)

    if status := rr.Code; status != http.StatusOK {
        t.Errorf("handler returned wrong status code: got %v want %v", status, http.StatusOK)
    }
}
```

## Best Practices

### 1. Use Table-Driven Tests

```go
func TestAPIEndPoint(t *testing.T) {
    tests := []struct {
        name       string
        method     string
        path       string
        body       io.Reader
        wantStatus int
        wantBody   string
    }{
        {
            name:       "get user",
            method:     "GET",
            path:       "/api/users/123",
            wantStatus: http.StatusOK,
            wantBody:   `{"id":"123","name":"John"}`,
        },
        {
            name:       "user not found",
            method:     "GET",
            path:       "/api/users/999",
            wantStatus: http.StatusNotFound,
            wantBody:   `{"error":"user not found"}`,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            req := httptest.NewRequest(tt.method, tt.path, tt.body)
            rr := httptest.NewRecorder()

            handler := http.HandlerFunc(APIHandler)
            handler.ServeHTTP(rr, req)

            if rr.Code != tt.wantStatus {
                t.Errorf("status code = %d, want %d", rr.Code, tt.wantStatus)
            }

            if strings.TrimSpace(rr.Body.String()) != tt.wantBody {
                t.Errorf("body = %q, want %q", rr.Body.String(), tt.wantBody)
            }
        })
    }
}
```

### 2. Exclude Generated Code

```go
//go:generate go run generate.go
//go:build !coverage

package main

// Generate code here
```

### 3. Focus on Critical Paths

```go
func TestCriticalPath(t *testing.T) {
    tests := []struct {
        name    string
        input   string
        want    string
        wantErr bool
    }{
        // Core functionality
        {"basic case", "input", "output", false},

        // Edge cases
        {"empty input", "", "", true},
        {"invalid input", "invalid", "", true},

        // Boundary conditions
        {"max length", strings.Repeat("a", maxLen), "", true}
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got, err := Process(tt.input)
            if (err != nil) != tt.wantErr {
                t.Errorf("Process() error = %v, wantErr %v", err, tt.wantErr)
                return
            }
            if got != tt.want {
                t.Errorf("Process() = %v, want %v", got, tt.want)
            }
        })
    }
}
```

## Coverage Analysis

### Statement Coverage

```go
func ExampleFunction() {
    // This line is covered
    fmt.Println("Hello")

    if someCondition {
        // This might not be covered
        fmt.Println("Conditional ")
    }
}

func TestExampleFunction(t *testing.T) {
    ExampleFunction() // Only covers the first line
}
```

### Branch Coverage

```go
func ProcessValue(val int) string {
    if val < 0 {
        return "negative"
    } else if val == 0 {
        return "zero"
    } else {
        return "positive"
    }
}

func TestProcessValue(t *testing.T) {
    tests := []struct {
        name string
        val  int
        want string
    }{
        {"negative", -1, "negative"},
        {"zero", 0, "zero"},
        {"positive", 1, "positive"},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            if got := ProcessValue(tt.val); got != tt.want {
                t.Errorf("ProcessValue() = %v, want %v", got, tt.want)
            }
        })
    }
}
```

### Function Coverage

```go
type Service struct {
    db Database
}

func (s *Service) ProcessItem(item *Item) error {
    // Coverage should include error paths
    if err := s.validate(item); err != nil {
        return fmt.Errorf("validation failed: %w", err)
    }

    if err := s.db.Save(item); err != nil {
        return fmt.Errorf("save failed: %w", err)
    }

    return nil
}

func TestService_ProcessItem(t *testing.T) {
    tests := []struct {
        name    string
        item    *Item
        dbErr   error
        wantErr bool
    }{
        {
            name:    "success",
            item:    &Item{Valid: true},
            wantErr: false,
        },
        {
            name:    "invalid item",
            item:    &Item{Valid: false},
            wantErr: true,
        },
        {
            name:    "db error",
            item:    &Item{Valid: true},
            dbErr:   errors.New("db error"),
            wantErr: true,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            mockDB := &MockDB{err: tt.dbErr}
            s := &Service{db: mockDB}

            err := s.ProcessItem(tt.item)
            if (err != nil) != tt.wantErr {
                t.Errorf("ProcessItem() err = %v, wantErr %v", err, tt.wantErr)
            }
        })
    }
}
```

## Continuous Integration

### GitHub Actions Example

```yaml
name: Test Coverage

on:
    push:
        branches: [ main ]
    pull_request:
        branches: [ main ]

jobs:
    coverage:
        runs-on: ubuntu-latest
        steps:
        - uses: actions/checkout@v2

        - name: Set up Go
            uses: actions/setup-go@v2
            with:
                go-version: '1.21'

        - name: Run Tests
            run: |
                go test -race -coverprofile=coverage.out -covermode=atomic ./...

        - name: Upload coverage to Codecov
            uses: codecov/codecov-action@v2
            with:
                file: ./coverage.out
                fail_ci_if_error: true
```

## Next Steps

Start learning [Integration Testing](6.7_integration_tests.md)

## Additional Resources

- [Go Documentation](https://go.dev/doc)
- [Go by Example](https://gobyexample.com)
- [Go Tour](https://go.dev/tour/welcome/1)
- [Effective Go](https://go.dev/doc/effective_go)
- [Go Playground](https://go.dev/play)
- [WebReference - Guide to Go](https://webreference.com/go)
