# Database Connection Pooling in Go

Connection pooling is essential for managing database database connections efficiently in Go applications. This guide covers how to implement and manage connection pools effectively.

## Basic Pool Configuration

### SQL Connection Pool

```go
package main

import (
    "context"
    "database/sql"
    "time"

    _ "github.com/lib/pq"
)

type DBConfig struct {
    MaxOpenConns    int
    MaxIdleConns    int
    ConnMaxLifetime time.Duration
    ConnMaxIdleTime time.Duration
}

func NewDB(dsn string, config DBConfig) (*sql.DB, error) {
    db, err := sql.Open("postgres", dsn)
    if err != nil {
        return nil, err
    }

    // Set pool configuration
    db.SetMaxOpenConns(config.MaxOpenConns)
    db.SetMaxIdleConns(config.MaxIdleConns)
    db.SetConnMaxLifetime(config.ConnMaxLifetime)
    db.SetConnMaxIdleTime(config.ConnMaxIdleTime)

    // Verify connection
    ctx, cancel := context.WithTimeout(contxt.Backgroud(), 5*time.Second)
    defer cancel()

    if err := db.PingContext(ctx); err != nil {
        return nil, err
    }

    return db, nil
}

// Usage example
func main() {
    config := DBConfig{
        MaxOpenConns:    25,
        MaxIdleConns:    10,
        ConnMaxLifetime: 30 * time.Minute,
        ConnMaxIdleTime: 10 * time.Minute,
    }

    db, err := NewDB(
        "postgres://user:pass@localhost/dbname?sslmode=disable",
        config,
    )
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()
}
```

### GORM Connection Pool

```go
import (
    "gorm.io/driver/postgres"
    "gorm.io/gorm"
)

type GormConfig struct {
    DSN             string
    MaxOpenConns    int
    MaxIdleConns    int
    ConnMaxLifetime time.Duration
    ConnMaxIdleTime time.Duration
}

func NewGormDB(config GormConfig) (*gorm.DB, error) {
    db, err := gorm.Open(postgres.Open(config.DSN), &gorm.Config{})
    if err != nil {
        return nil, err
    }

    sqlDB, err := db.DB()
    if err != nil {
        return nil, err
    }

    // Set Pool configuration
    sqlDB.SetMaxOpenConns(config.MaxOpenConns)
    sqlDB.SetMaxIdleConns(config.MaxIdleConns)
    sqlDB.SetConnMaxLifetime(config.ConnMaxLifetime)
    sqlDB.SetConnMaxIdleTime(config.ConnMaxIdleTime)

    return db, nil
}
```

## Pool Management

### Connection Monitor

```go
type ConnectionMonitor struct {
    db     *sql.DB
    logger *log.Logger
    done   chan struct{}
}

func NewConnectionMonitor(db *sql.DB, logger *log.Logger) *ConnectionMonitor {
    return &ConnectionMonitor{
        db:     db,
        logger: logger,
        done:   make(chan struct{}),
    }
}

func (m *ConnectionMonitor) Start(interval time.Duration) {
    ticker := time.NewTicker(interval)
    go func() {
        for {
            select {
            case <-ticker.C:
                stats := m.db.Stats()
                m.logger.Printf(
                    "DB Stats - Open: %d, Idle: %d, InUse: %d, WaitCount: %d, WaitDuration: %s",
                    stats.OpenConnections,
                    stats.Idle,
                    stats.InUse,
                    stats.WaitCount,
                    stats.WaitDuration,
                )
            case <-m.done:
                ticker.Stop()
                return
            }
        }
    }()
}

func (m *ConnectionMonitor) Stop() {
    close(m.done)
}
```

### 2. Health Check

```go
type HealthChecker struct {
    db       *sql.DB
    timeout  time.Duration
    failures int64
}

func NewHealthChecker(db *sql.DB, timeout time.Duration) *HealthChecker {
    return &HealthChecker{
        db:      db,
        timeout: timeout,
    }
}

func (hc *HealthChecker) Check() error {
    ctx, cancel := context.WithTimeout(context.Background(), hc.timeout)
    defer cancel()

    if err := hc.db.PingContext(ctx); err != nil {
        atomic.AddInt64(&hc.failures, 1)
        return fmt.Errorf("database ping failed: %v", err)
    }

    atomic.StoreInt64(&hc.failures, 0)
    return nil
}

func (hc *HealthChecker) GetFailures() int64 {
    return atomic.LoadInt64(&hc.failures)
}
```

### 3. Connection Wrapper

```go
type DBWrapper struct {
    db      *sql.DB
    metrics *ConnectionMetrics
}

type ConnectionMetrics struct {
    ActiveQueries    int64
    CompletedQueries int64
    ErrorCount       int64
    QueryDuration    []time.Duration
}

func NewDBWrapper(db *sql.DB) *DBWrapper {
    return &DBWrapper{
        db: db,
        metrics: &ConnectionMetrics{
            QueryDurations: make([]time.Duration, 0),
        },
    }
}

func (w *DBWrapper) QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) {
    atomic.AddInt64(&w.metrics.ActiveQueries, 1)
    defer atomic.AddInt64(&w.metrics.ActiveQueries, -1)

    start := time.Now()
    rows, err := w.db.QueryContext(ctx, query, args...)
    duration := time.Since(start)

    atomic.AddInt64(&w.metrics.CompletedQueries, 1)
    w.metrics.QueryDurations = append(w.metrics.QueryDurations, duration)

    if err != nil {
        atomic.AddInt64(&w.metrics.ErrorCount, 1)
    }

    return rows, err
}
```

## Best Practices

### 1. Pool Configuration

```go
type PoolConfig struct {
    // Basic settings
    MaxOpenConns    int           `json:"max_open_conns"`
    MaxIdleConns    int           `json:"max_idle_conns"`
    ConnMaxLifetime time.Duration `json:"conn_max_lifetime"`
    ConnMaxIdleTime time.Duration `json:"conn_max_idle_time"`

    // Advanced settings
    MaxRetries     int           `json:"max_retries"`
    RetryInterval  time.Duration `json:"retry_interval"`
    HealthInterval time.Duration `json:"health_interval"`
    MetricsEnabled bool          `json:"metrics_enabled"`
}
```

## Next Steps

Start learning Connection Pooling

## Additional Resources

- [Go Documentation](https://go.dev/doc)
- [Go by Example](https://gobyexample.com)
- [Go Tour](https://go.dev/tour/welcome/1)
- [Effective Go](https://go.dev/doc/effective_go)
- [Go Playground](https://go.dev/play)
- [WebReference - Guide to Go](https://webreference.com/go)
