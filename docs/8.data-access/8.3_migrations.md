# Managing Database Migrations in Go

## What are Database Migrations?

Database migrations are a systematic way to manage changes to your database schema over time. They serve several crucial purposes:

### 1. Version Control for Your Database:

- Track changes to database structure
- Roll back changes when needed
- Maintain consistency across environments

### 2. Team Collaboration:

- Share database changes with team members
- Review schema modifications
- Resolve conflicts in database changes

### 3. Deployment Management:

- Ensure consistent database state across environments
- Automate database updates during deployment
- Maintain data integrity during schema changes

## Migration Concepts

### 1. Migration Files

Migration files are the building blocks of schema management. Each migration file:

- Has a unique version number (usually a timestamp)
- Contains 'up' and 'down' migrations
- Is immutable once deployed
- Should be atomic and focused

### 2. Migration State

Migrations maintain state through:

- A migrations table in your database
- Version tracking
- "Dirty" state detection for failed migrations

### 3. Migration Types

#### 1. Schema Migrations:

- Table creation/modification
- Index management
- Constraint changes

#### 2. Data Migrations:

- Data transformation
- Data cleanup
- Backfilling new columns

## Using golang-migrate

The `golang-migrate` package is a powerful tool for managing database migrations. Here's how to use it effectively:

### Basic Setup

```go
package main

import (
    "database/sql"
    "log"

    "github.com/golang-migrate/migrate/v4"
    "github.com/golang-migrate/migrate/v4/database/postgres"
    _ "github.com/golang-migrate/migrate/v4/source/file"
)

func main() {
    // Connect to database
    db, err := sql.Open("postgres", "postgres://user:pass@localhost/dbname?sslmode=disable")
    if err != nil {
        log.Fatal(err)
    }

    // Create migration instance
    driver, err := postgres.WithInstance(db, &postgres.Config{})
    if err != nil {
        log.Fatal(err)
    }

    m, err := migrate.NewWithDatabaseInstance(
        "file://migrations",
        "postgres",
        driver,
    )
    if err != nil {
        log.Fatal(err)
    }

    // Run migrations
    if err := m.Up(); err != nil && err != migrate.ErrNoChange {
        log.Fatal(err)
    }
}
```

### Writing Effective Migrations

Migration files should be clear, focused, and reversible. Here's an example:

```sql
-- 20240319000001_create_users.up.sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_users_email ON users(email);

-- 20240319000001_create_users.down.sql
DROP TABLE users;
```

## Best Practices

### 1. Migration Naming

Migrations should follow a consistent naming pattern:

- Use timestamps for version numbers
- Include descriptive names
- Separate words with underscores
- Indicate migration type if relevant

Example naming pattern:

```txt
YYYYMMDDHHMMSS_action_table_name.up.sql
20240319120000_create_users_table.up.sql
20240319120001_add_user_roles.up.sql
20240319120002_backfill_user_roles.up.sql
```

### 2. Migration Safety

When writing migrations, consider:

#### 1. Backward Compatibility:

- Add columns as nullable or with defaults
- Create new tables before migrating data
- Keep old columns until new code is deployed

#### 2. Performance Impact:

- Use batching for large data migrations
- Consider table locks and their impact
- Plan for migration duration

#### 3. Data Integrity:

- Validate data before and after migration
- Include data checks in migration
- Have rollback plans ready

### 3. Testing Migrations

Always test migrations:

1. Test both up and down migrations
2. Verify data integrity after migration
3. Test with representative data volumes
4. Include migration tests in CI/CD

## Common Patterns

### 1. Transactional Migrations

Wrap migrations in transactions when possible:

```go
type TransactionalMigration struct {
    Up   func(*sql.Tx) error
    Down func(*sql.Tx) error
}

func (m *TransactionalMigration) Execute(db *sql.DB, direction string) error {
    tx, err := db.Begin()
    if err != nil {
        return err
    }
    defer tx.Rollback()

    var migrationFunc func(*sql.Tx) error
    if direction == "up" {
        migrationFunc = m.Up
    } else {
        migrationFunc = m.Down
    }

    if err := migrationFunc(tx); err != nil {
        return err
    }

    return tx.Commit()
}
```

### 2. Data Migrations

For large datasets, use batching

```go
type DataMigration struct {
    BatchSize int
    Query     string
}

func (m *DataMigration) Execute(db *sql.DB) error {
    for {
        tx, err := db.Begin()
        if err != nil {
            return err
        }

        result, err := tx.Exec(m.Query, m.BatchSize)
        if err != nil {
            tx.Rollback()
            return err
        }

        affected, err := result.RowsAffected()
        if err != nil {
            tx.Rollback()
            return err
        }

        if err := tx.Commit(); err != nil {
            return err
        }

        if affected < int64(m.BatchSize) {
            break
        }
    }

    return nil
}
```

## Troubleshooting Migrations

Common issues and solutions:

### 1. Failed Migrations:

- Check the migrations table for "dirty" state
- Review error logs
- Use force version as last resort

### 2. Version Conflicts:

- Ensure unique version numbers
- Coordinate with team on new migrations
- Use version control for migration files

### 3. Performance Issues:

- Monitor migration duration
- Use EXPLAIN ANALYZE for queries
- Consider table locks and their impact

## Next Steps

Start learning [ORMs](8.4_orms.md)

## Additional Resources

- [Go Documentation](https://go.dev/doc)
- [Go by Example](https://gobyexample.com)
- [Go Tour](https://go.dev/tour/welcome/1)
- [Effective Go](https://go.dev/doc/effective_go)
- [Go Playground](https://go.dev/play)
- [WebReference - Guide to Go](https://webreference.com/go)
