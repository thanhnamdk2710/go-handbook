# Using ORMs in Go

Go's Object-Relational Mapping (ORM) libraries bridge the gap between your Go code and relational databases. This guide will help you understand when and how to effectively use ORMs in your applications.

## Understanding ORMs

### What is an ORM?

An Object-Relational Mapper (ORM) is a layer between your application code and database that:

- Translates between Go structs and database tables
- Handles database operations through Go methods
- Manages relationships between different data models
- Provides query building capabilities

### When to Use an ORM

ORMs are most beneficial when:

1. You need rapid development and prototyping
2. Your application has complex object relationships
3. You want database-agnostic code
4. You prefer working with objects over raw SQL

However, consider these trade-offs:

1. Performance overhead compared to raw SQL
2. Learning curve for ORM-specific APIs
3. Potential for inefficient queries
4. Less control over database operations

## GORM Fundamentals

GORM is the most popular ORM for Go. Here's what you need to know:

### 1. Model Definition

Models are the foundation of GORM. They define:

- Table structure
- Field relationships
- Validation rules
- Callbacks

Example of a well-structured model:

```go
package main

import (
    "time"

    "gorm.io/gorm"
)

type User struct {
    ID        uint           `gorm:"primaryKey"`
    Name      string         `gorm:"size:255;not null"`
    Email     string         `gorm:"size:255;not null;unique"`
    Password  string         `gorm:"size:255;not null"`
    Posts     []Post         `gorm:"foreignKey:UserID"`
    CreatedAt time.Time
    UpdatedAt time.Time
    DeletedAt gorm.DeletedAt `gorm:"index"`
}

type Post struct {
    ID        uint      `gorm:"primaryKey"`
    Title     string    `gorm:"size:255;not null"`
    Content   string    `gorm:"type:text"`
    UserID    uint
    User      User      `gorm:"foreignKey:UserID"`
    Tags      []Tag     `gorm:"many2many:post_tags"`
    CreatedAt time.Time
    UpdatedAt time.Time
}

type Tag struct {
    ID    uint   `gorm:"primaryKey"`
    Name  string `gorm:"size:255;not null;unique"`
    Posts []Post `gorm:"many2many:post_tags"`
}
```

Key concepts in model definition:

- Tags define database constraints and relationships
- Conventions determine table and column names
- Timestamps are automatically managed
- Soft delete is built-in

### 2. Relationships

GORM supports four types of relationships:

1. `Has One`: One-to-one relationship
2. `Has Many`: One-to-many relationship
3. `Belongs To`: Inverse of Has One/Has Many
4. `Many to Many`: Many-to-many relationship

Understanding relationship loading:

- Eager loading with Preload
- Lazy loading with association
- Join preloading for better performance

### 3. Query Interface

GORM provides a rich query interface:

- Method chaining for complex queries
- Automatic transaction handling
- Hooks for custom logic
- Scopes for reusable queries

### Best Practices

#### 1. Model Organization

Keep your models clean and maintainable:

```go
type BaseModel struct {
    ID        uint           `gorm:"primaryKey"`
    CreatedAt time.Time
    UpdatedAt time.Time
    DeletedAt gorm.DeletedAt `gorm:"index"`
}

type User struct {
    BaseModel
    Name     string `gorm:"size:255;not null"`
    Email    string `gorm:"size:255;not null;unique"`
    Password string `gorm:"size:255;not null"`
}
```

#### 2. Repository Pattern

Encapsulate database operations:

```go
type UserRepository struct {
    db *gorm.DB
}

func (r *UserRepository) Create(user *User) error {
    return r.db.Create(user).Error
}

func (r *UserRepository) FindByID(id uint) (*User, error) {
    var user User
    if err := r.db.First(&user, id).Error; err != nil {
        return nil, err
    }
    return &user, nil
}
```

### 3. Error Handling

Handle GORM errors appropriately:

```go
func handleGormError(err error) error {
    switch {
    case errors.Is(err, gorm.ErrRecordNotFound):
        return fmt.Errorf("record not found")
    case strings.Contains(err.Error(), "unique constraint"):
        return fmt.Errorf("duplicate record")
    default:
        return fmt.Errorf("database error: %v", err)
    }
}
```

## Common Patterns

### 1. Soft Delete

Implement soft delete with custom logic:

```go
type SoftDeletable interface {
    Restore() error
    ForceDelete() error
}

func (m *BaseModel) Restore() error {
    return db.Model(m).Update("deleted_at", nil).Error
}

func (m *BaseModel) ForceDelete() error {
    return db.Unscoped().Delete(m).Error
}
```

### 2. Audit Trail

Track changes to your models:

```go
type Auditable struct {
    CreatedBy uint
    UpdatedBy uint
}

func (a *Auditable) BeforeCreate(tx *gorm.DB) error {
    if user, ok := tx.Statement.Context.Value("current_user").(uint); ok {
        a.CreatedBy = user
        a.UpdatedBy = user
    }
    return nil
}
```

## Performance Optimization

### 1. Query Optimization

Improve query performance:

- Use indexes appropriately
- Eager load related data
- Batch operations for bulk updates
- Monitor query execution time

### 2. Connection Management

Optimize database connections:

- Configure connection pool size
- Set appropriate timeouts
- Monitor connection usage
- Handle connection errors

## Troubleshooting

Common issues and solutions:

### 1. N+1 Query Problem:

- Symptom: Multiple queries for related data
- Solution: Use Preload or Joins
- Prevention: Monitor query counts

### 2. Memory Usage:

- Issue: Large result sets
- Solution: Use pagination
- Prevention: Limit query results

### 3. Performance:

- Problem: Slow queries
- Solution: Use database profiling
- Prevention: Regular monitoring

## Next Steps

Start learning NoSQL

## Additional Resources

- [Go Documentation](https://go.dev/doc)
- [Go by Example](https://gobyexample.com)
- [Go Tour](https://go.dev/tour/welcome/1)
- [Effective Go](https://go.dev/doc/effective_go)
- [Go Playground](https://go.dev/play)
- [WebReference - Guide to Go](https://webreference.com/go)
